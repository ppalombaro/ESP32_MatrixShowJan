/* ThemeManager.cpp - V15.0.1
   Complete theme management with multi-holiday support
   VERSION: V15.0.1-2026-01-03T14:00:00Z - Music removed, countdown config added
   
   V15.0.1-2026-01-03T14:00:00Z - Removed all music code (6 animations)
   V15.0.1-2026-01-03T14:00:00Z - Added countdown date configuration
   V15.0.1-2026-01-03T14:00:00Z - Reduced animations from 20 to 14
*/

#include "ThemeManager.h"
#include "Logger.h"
#include <Preferences.h>  
#include <FastLED.h>

extern Preferences preferences;
extern Logger logger;  // V15.0.1-2026-01-03T14:00:00Z

#define TOTAL_STATIC_SCENES 6 
#define TOTAL_ANIMATIONS 14  // V15.0.1-2026-01-03T14:00:00Z - Was 20, removed 6 music
#define TOTAL_TEST_PATTERNS 2

// V15.0-2025-01-02T19:20:00Z - Holiday content counts
#define TOTAL_HALLOWEEN_SCENES 6#define TOTAL_HALLOWEEN_ANIMS 2  // bleeding_windows, spooky_eyes
#define TOTAL_THANKSGIVING_SCENES 1
#define TOTAL_THANKSGIVING_ANIMS 1  // falling_leaves only
#define TOTAL_NEWYEAR_SCENES 1
#define TOTAL_NEWYEAR_ANIMS 2  // fireworks, spinning_star (countdown/scroll still hardcoded)
#define TOTAL_OSU_SCENES 1
#define TOTAL_OSU_ANIMS 2  // OHIO letters, color wave (both still hardcoded - OK)

ThemeManager::ThemeManager() {
    disp = nullptr;
    sceneData = nullptr;  // V15.2.3-2026-01-04T14:35:00Z
    staticScenes = nullptr;
    testScenes = nullptr;
    chaseAnimation = nullptr;
    snowfallEffect = nullptr;
    scrollAnimation = nullptr;
    countdownAnimation = nullptr;
    spinningSnowflake = nullptr;
    sparklingStar = nullptr;
    // V15.0.1-2026-01-03T14:00:00Z - Removed musicLightShow pointer
    concentricRectangles = nullptr;
    concentricCircles = nullptr;
    concentricTriangles = nullptr;
    morphingGeometry = nullptr;
    
    // V15.0-2025-01-02T19:20:00Z - Initialize holiday pointers
    flyingBats = nullptr;
    pirateShip = nullptr;
    bleedingWindows = nullptr;
    lightningFlash = nullptr;
    halloweenScroll = nullptr;
    spookyEyes = nullptr;  // V15.0.3.1 - 2025-01-03
    thanksgivingScroll = nullptr;
    fallingLeaves = nullptr;
    newYearCountdown = nullptr;
    newYearScroll = nullptr;
    fireworks = nullptr;
    colorSpinningStar = nullptr;
    osuScroll = nullptr;
    ohioLetters = nullptr;
    osuColorWave = nullptr;
}

ThemeManager::~ThemeManager() {
    // V15.0-2025-01-02T19:20:00Z - Delete holiday objects
    delete osuColorWave;
    delete ohioLetters;
    delete osuScroll;
    delete colorSpinningStar;
    delete fireworks;
    delete newYearScroll;
    delete newYearCountdown;
    delete fallingLeaves;
    delete thanksgivingScroll;
    delete spookyEyes;      // V15.0.3.1 - 2025-01-03
    delete halloweenScroll;
    delete lightningFlash;
    delete bleedingWindows;
    delete pirateShip;
    delete flyingBats;
    
    // Christmas objects
    delete morphingGeometry;
    delete concentricTriangles;
    delete concentricCircles;
    delete concentricRectangles;
    // V15.0.1-2026-01-03T14:00:00Z - Removed: delete musicLightShow;
    delete sparklingStar;
    delete spinningSnowflake;
    delete countdownAnimation;
    delete scrollAnimation;
    delete snowfallEffect;
    delete chaseAnimation;
    delete testScenes;
    delete staticScenes;
    delete sceneData;  // V15.2.3-2026-01-04T14:35:00Z - Cleanup SceneData
}

void ThemeManager::begin(MatrixDisplay* display) {
    disp = display;
    
    preferences.begin(PREFS_NAMESPACE, false);
    uint8_t savedBrightness = preferences.getUChar(BRIGHTNESS_KEY, 128);
    preferences.end();
    setBrightness(savedBrightness);
    
    // V15.2.3-2026-01-04T14:35:00Z - Initialize SPIFFS scene renderer
    sceneData = new SceneData(disp);
    
    // Initialize Christmas objects
    staticScenes = new Scenes(disp);
    testScenes = new TestScenes(disp);
    chaseAnimation = new ChaseAnimation(disp);
    snowfallEffect = new SnowfallEffect(disp);
    scrollAnimation = new ScrollAnimation(disp);
    countdownAnimation = new MerryChristmasCount(disp);
    spinningSnowflake = new SpinningSnowflake(disp);
    sparklingStar = new SparklingStar(disp);
    // V15.0.1-2026-01-03T14:00:00Z - Removed: musicLightShow = new MusicLightShow(disp);
    concentricRectangles = new ConcentricRectangles(disp);
    concentricCircles = new ConcentricCircles(disp);
    concentricTriangles = new ConcentricTriangles(disp);
    morphingGeometry = new MorphingGeometry(disp);

    // V15.0-2025-01-02T19:20:00Z - Initialize holiday objects
    flyingBats = new FlyingBatsAnimation(disp);
    pirateShip = new PirateShipAnimation(disp);
    bleedingWindows = new BleedingWindowsAnimation(disp);
    lightningFlash = new LightningFlashAnimation(disp);
    halloweenScroll = new HalloweenScrollText(disp);
    spookyEyes = new SpookyTrackingEyesAnimation(disp);  // V15.0.3.1 - 2025-01-03
    thanksgivingScroll = new ThanksgivingScrollText(disp);
    fallingLeaves = new FallingLeavesAnimation(disp);
    newYearCountdown = new NewYearCountdown(disp);
    newYearScroll = new NewYearScrollText(disp);
    fireworks = new FireworksAnimation(disp);
    colorSpinningStar = new ColorSpinningStarAnimation(disp);
    osuScroll = new OSUScrollText(disp);
    ohioLetters = new OHIOLetterAnimation(disp);
    osuColorWave = new OSUColorWaveAnimation(disp);

    // Initialize Christmas animations
    snowfallEffect->begin();
    chaseAnimation->begin();
    scrollAnimation->begin();
    countdownAnimation->begin();
    spinningSnowflake->begin();
    sparklingStar->begin();
    // V15.0.1-2026-01-03T14:00:00Z - Removed: musicLightShow->begin();
    concentricRectangles->begin();
    concentricCircles->begin();
    concentricTriangles->begin();
    morphingGeometry->begin();

    // V15.0-2025-01-02T19:20:00Z - Initialize holiday animations
    flyingBats->begin();
    pirateShip->begin();
    bleedingWindows->begin();
    lightningFlash->begin();
    halloweenScroll->begin();
    thanksgivingScroll->begin();
    fallingLeaves->begin();
    newYearCountdown->begin();
    newYearScroll->begin();
    fireworks->begin();
    colorSpinningStar->begin();
    osuScroll->begin();
    ohioLetters->begin();
    osuColorWave->begin();

    loadRandomShowConfig();
    
    // V15.0.1-2026-01-03T14:00:00Z - Load countdown dates
    loadCountdownDates();
    
    disp->clear();
    disp->show();

    setTheme(THEME_OFF); 
}

void ThemeManager::update() {
    // V15.0.2-2026-01-03T17:00:00Z - Cache static scenes (don't redraw if unchanged)
    // Saves 30% CPU when showing static content
    static uint8_t lastStaticScene = 255;
    static uint8_t lastStaticTheme = 255;
    
    switch (currentTheme) {
        case THEME_OFF:
            disp->clear();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;

        case THEME_CHRISTMAS_STATIC:
            // V15.0.2-2026-01-03T17:00:00Z - Only redraw if scene changed
            if (currentScene != lastStaticScene || currentTheme != lastStaticTheme) {
                drawStaticChristmasScene(0, currentScene);
                drawStaticChristmasScene(1, currentScene);
                disp->show();
                lastStaticScene = currentScene;
                lastStaticTheme = currentTheme;
            }
            break;

        case THEME_CHRISTMAS_ANIMATED:
            updateCurrentAnimation();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;

        case THEME_RANDOM_MAGIC:
            updateRandomMagic();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;
            
        // V15.0-2025-01-02T19:20:00Z - Holiday theme cases
        case THEME_HALLOWEEN_STATIC:
            // V15.0.2-2026-01-03T17:00:00Z - Cache static scenes
            if (currentScene != lastStaticScene || currentTheme != lastStaticTheme) {
                drawHalloweenScene(0, currentScene);
                drawHalloweenScene(1, currentScene);
                disp->show();
                lastStaticScene = currentScene;
                lastStaticTheme = currentTheme;
            }
            break;
            
        case THEME_HALLOWEEN_ANIMATED:
            updateHalloweenAnimation();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;
            
        case THEME_THANKSGIVING_STATIC:
            // V15.0.2-2026-01-03T17:00:00Z - Cache static scenes
            if (currentScene != lastStaticScene || currentTheme != lastStaticTheme) {
                drawThanksgivingScene(0, currentScene);
                drawThanksgivingScene(1, currentScene);
                disp->show();
                lastStaticScene = currentScene;
                lastStaticTheme = currentTheme;
            }
            break;
            
        case THEME_THANKSGIVING_ANIMATED:
            updateThanksgivingAnimation();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;
            
        case THEME_NEWYEAR_STATIC:
            // V15.0.2-2026-01-03T17:00:00Z - Cache static scenes
            if (currentScene != lastStaticScene || currentTheme != lastStaticTheme) {
                drawNewYearScene(0, currentScene);
                drawNewYearScene(1, currentScene);
                disp->show();
                lastStaticScene = currentScene;
                lastStaticTheme = currentTheme;
            }
            break;
            
        case THEME_NEWYEAR_ANIMATED:
            updateNewYearAnimation();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;
            
        case THEME_OSU_STATIC:
            // V15.0.2-2026-01-03T17:00:00Z - Cache static scenes
            if (currentScene != lastStaticScene || currentTheme != lastStaticTheme) {
                drawOSUScene(0, currentScene);
                drawOSUScene(1, currentScene);
                disp->show();
                lastStaticScene = currentScene;
                lastStaticTheme = currentTheme;
            }
            break;
            
        case THEME_OSU_ANIMATED:
            updateOSUAnimation();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;

        case THEME_TEST_MODE:
            updateTestPattern();
            disp->show();
            lastStaticScene = 255;  // V15.0.2-2026-01-03T17:00:00Z - Reset cache
            break;
    }
}


// V15.0-2025-01-02T19:20:00Z - Holiday animation update functions

void ThemeManager::updateHalloweenAnimation() {
    switch (currentAnimation) {
        case 0: flyingBats->update(); break;
        case 1: pirateShip->update(); break;
        case 2: bleedingWindows->update(); break;
        case 3: lightningFlash->update(); break;
        case 4: 
            halloweenScroll->setMessage("HAPPY HALLOWEEN");
            halloweenScroll->update();
            break;
        case 5:  // V15.0.3.1 - 2025-01-03 - Spooky tracking eyes
            spookyEyes->update();
            break;
        default: break;
    }
}

void ThemeManager::updateThanksgivingAnimation() {
    switch (currentAnimation) {
        case 0: thanksgivingScroll->update(); break;
        case 1: fallingLeaves->update(); break;
        default: break;
    }
}

void ThemeManager::updateNewYearAnimation() {
    switch (currentAnimation) {
        case 0: newYearCountdown->update(); break;
        case 1: newYearScroll->update(); break;
        case 2: fireworks->update(); break;
        case 3: colorSpinningStar->update(); break;
        default: break;
    }
}

void ThemeManager::updateOSUAnimation() {
    switch (currentAnimation) {
        case 0: osuScroll->update(); break;
        case 1: ohioLetters->update(); break;
        case 2: osuColorWave->update(); break;
        default: break;
    }
}

// V15.0-2025-01-02T19:20:00Z - Holiday scene drawing functions

void ThemeManager::drawHalloweenScene(int matrix, uint8_t sceneIndex) {
    if (!sceneData || matrix < 0 || matrix > 1) return;  // V15.2.3-2026-01-04T14:35:00Z
    sceneIndex = sceneIndex % TOTAL_HALLOWEEN_SCENES;

    switch (sceneIndex) {
        case 0: sceneData->drawPumpkin(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
        case 1: sceneData->drawBat(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
        case 2: sceneData->drawGhost(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
        case 3: sceneData->drawJasonMask(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
        case 4: sceneData->drawSkull(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
        case 5: sceneData->drawPirateFlag(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
    }
}

void ThemeManager::drawThanksgivingScene(int matrix, uint8_t sceneIndex) {
    if (!sceneData || matrix < 0 || matrix > 1) return;  // V15.2.3-2026-01-04T14:35:00Z
    sceneIndex = sceneIndex % TOTAL_THANKSGIVING_SCENES;

    switch (sceneIndex) {
        case 0: sceneData->drawTurkey(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
    }
}

void ThemeManager::drawNewYearScene(int matrix, uint8_t sceneIndex) {
    if (!sceneData || matrix < 0 || matrix > 1) return;  // V15.2.3-2026-01-04T14:35:00Z
    sceneIndex = sceneIndex % TOTAL_NEWYEAR_SCENES;

    switch (sceneIndex) {
        case 0: sceneData->drawFirework(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
    }
}

void ThemeManager::drawOSUScene(int matrix, uint8_t sceneIndex) {
    if (!sceneData || matrix < 0 || matrix > 1) return;  // V15.2.3-2026-01-04T14:35:00Z
    sceneIndex = sceneIndex % TOTAL_OSU_SCENES;

    switch (sceneIndex) {
        case 0: sceneData->drawOhioStateLogo(matrix); break;  // V15.2.3-2026-01-04T14:35:00Z
    }
}

// V15.0.1-2026-01-03T14:00:00Z - Christmas animation update (music removed, renumbered)
void ThemeManager::updateCurrentAnimation() {
    switch (currentAnimation) {
        case 0: snowfallEffect->setMode(MODE_BASIC); snowfallEffect->update(); break;
        case 1: snowfallEffect->setMode(MODE_WIND_SINGLE); snowfallEffect->update(); break;
        case 2: snowfallEffect->setMode(MODE_WIND_VARY); snowfallEffect->update(); break;
        case 3: snowfallEffect->setMode(MODE_ACCUMULATE); snowfallEffect->update(); break;
        case 4: snowfallEffect->setMode(MODE_VARY_SIZE); snowfallEffect->update(); break;
        case 5: chaseAnimation->update(); break;
        case 6: scrollAnimation->update(); break;
        case 7: countdownAnimation->update(); break;
        case 8: sparklingStar->update(); break;
        case 9: spinningSnowflake->update(); break;
        // V15.0.1-2026-01-03T14:00:00Z - Removed music animations (was cases 10-15)
        // V15.0.1-2026-01-03T14:00:00Z - Geometry animations renumbered from 16-19 to 10-13
        case 10: concentricRectangles->update(); break;
        case 11: concentricCircles->update(); break;
        case 12: concentricTriangles->update(); break;
        case 13: morphingGeometry->update(); break;
        default: break;
    }
}

void ThemeManager::updateTestPattern() {
    if (currentTest >= TOTAL_TEST_PATTERNS) {
        currentTest = 0;
    }
    
    drawTestScene(0, currentTest);
    drawTestScene(1, currentTest);
}

void ThemeManager::setTheme(uint8_t newTheme) {
    if (newTheme != currentTheme) {
        if (currentTheme == THEME_CHRISTMAS_ANIMATED || currentTheme == THEME_RANDOM_MAGIC ||
            currentTheme == THEME_HALLOWEEN_ANIMATED || currentTheme == THEME_THANKSGIVING_ANIMATED ||
            currentTheme == THEME_NEWYEAR_ANIMATED || currentTheme == THEME_OSU_ANIMATED) {
            stopAllAnimations();
        }
        
        currentTheme = newTheme;
        currentScene = 0;
        currentAnimation = 0;
        currentTest = 0;
        lastSceneChangeTime = millis();
        
        disp->clear();
        disp->show();
        
        if (newTheme == THEME_CHRISTMAS_ANIMATED) {
            drawAnimation(0, currentAnimation); 
        } else if (newTheme == THEME_RANDOM_MAGIC) {
            loadRandomShowConfig();
            int choice = random(3);
            if (choice == 0 && randomScenesMask != 0) {
                findNextRandomScene();
                if (randomContentType == 0) {
                    drawStaticChristmasScene(0, currentScene);
                    drawStaticChristmasScene(1, currentScene);
                }
            } else if (choice == 1 && randomAnimationsMask != 0) {
                findNextRandomAnimation();
            } else if (choice == 2 && randomTestsMask != 0) {
                findNextRandomTest();
            } else {
                if (randomScenesMask != 0) findNextRandomScene();
                else if (randomAnimationsMask != 0) findNextRandomAnimation();
                else if (randomTestsMask != 0) findNextRandomTest();
            }
            disp->show();
        } 
        // V15.0-2025-01-02T19:20:00Z - Initialize holiday animations when theme is set
        else if (newTheme == THEME_HALLOWEEN_ANIMATED) {
            switch(currentAnimation) {
                case 0: flyingBats->begin(); break;
                case 1: pirateShip->begin(); break;
                case 2: bleedingWindows->begin(); break;
                case 3: lightningFlash->begin(); break;
                case 4: halloweenScroll->begin(); break;
            }
        }
        else if (newTheme == THEME_THANKSGIVING_ANIMATED) {
            switch(currentAnimation) {
                case 0: thanksgivingScroll->begin(); break;
                case 1: fallingLeaves->begin(); break;
            }
        }
        else if (newTheme == THEME_NEWYEAR_ANIMATED) {
            switch(currentAnimation) {
                case 0: newYearCountdown->begin(); break;
                case 1: newYearScroll->begin(); break;
                case 2: fireworks->begin(); break;
                case 3: colorSpinningStar->begin(); break;
            }
        }
        else if (newTheme == THEME_OSU_ANIMATED) {
            switch(currentAnimation) {
                case 0: osuScroll->begin(); break;
                case 1: ohioLetters->begin(); break;
                case 2: osuColorWave->begin(); break;
            }
        }
    }
}

void ThemeManager::stopAllAnimations() {
    snowfallEffect->begin();
    chaseAnimation->begin();
    scrollAnimation->begin();
    countdownAnimation->begin();
    spinningSnowflake->begin();
    sparklingStar->begin();
    // V15.0.1-2026-01-03T14:00:00Z - Removed: musicLightShow->begin();
    concentricRectangles->begin();
    concentricCircles->begin();
    concentricTriangles->begin();
    morphingGeometry->begin();
    
    // V15.0-2025-01-02T19:20:00Z - Reset holiday animations
    flyingBats->begin();
    pirateShip->begin();
    bleedingWindows->begin();
    lightningFlash->begin();
    halloweenScroll->begin();
    thanksgivingScroll->begin();
    fallingLeaves->begin();
    newYearCountdown->begin();
    newYearScroll->begin();
    fireworks->begin();
    colorSpinningStar->begin();
    osuScroll->begin();
    ohioLetters->begin();
    osuColorWave->begin();
}

uint8_t ThemeManager::getCurrentTheme() {
    return currentTheme;
}

void ThemeManager::setSpecificScene(int sceneIndex) {
    setTheme(THEME_CHRISTMAS_STATIC); 
    if (sceneIndex >= 0 && sceneIndex < TOTAL_STATIC_SCENES) {
        currentScene = (uint8_t)sceneIndex;
        disp->clear(); 
        drawStaticChristmasScene(0, currentScene);
        drawStaticChristmasScene(1, currentScene);
        disp->show();
    }
}

void ThemeManager::setSpecificAnimation(int animIndex) {
    setTheme(THEME_CHRISTMAS_ANIMATED); 
    if (animIndex >= 0 && animIndex < TOTAL_ANIMATIONS) {
        currentAnimation = (uint8_t)animIndex;
        drawAnimation(0, currentAnimation); 
        disp->show();
    }
}

void ThemeManager::setSpecificTest(int testIndex) {
    setTheme(THEME_TEST_MODE);
    if (testIndex >= 0 && testIndex < 6) {
        currentAnimation = (uint8_t)testIndex;
        disp->clear();
        drawTestScene(0, currentAnimation);
        drawTestScene(1, currentAnimation);
        disp->show();
    }
}


void ThemeManager::loadRandomShowConfig() {
    preferences.begin(PREFS_NAMESPACE, true);
    randomScenesMask = preferences.getUChar(RANDOM_SCENES_MASK_KEY, DEFAULT_SCENES_MASK);
    randomAnimationsMask = preferences.getUInt(RANDOM_ANIMS_MASK_KEY, DEFAULT_ANIMS_MASK);
    randomTestsMask = preferences.getUChar(RANDOM_TESTS_MASK_KEY, DEFAULT_TESTS_MASK);
    preferences.end();
}

void ThemeManager::setRandomScenesMask(uint8_t mask) {
    randomScenesMask = mask;
    preferences.begin(PREFS_NAMESPACE, false);
    preferences.putUChar(RANDOM_SCENES_MASK_KEY, randomScenesMask);
    preferences.end();
}

void ThemeManager::setRandomAnimationsMask(uint32_t mask) {
    randomAnimationsMask = mask;
    preferences.begin(PREFS_NAMESPACE, false);
    preferences.putUInt(RANDOM_ANIMS_MASK_KEY, randomAnimationsMask);
    preferences.end();
}

void ThemeManager::setRandomTestsMask(uint8_t mask) {
    randomTestsMask = mask;
    preferences.begin(PREFS_NAMESPACE, false);
    preferences.putUChar(RANDOM_TESTS_MASK_KEY, randomTestsMask);
    preferences.end();
}

uint8_t ThemeManager::getRandomScenesMask() {
    return randomScenesMask;
}

uint32_t ThemeManager::getRandomAnimationsMask() {
    return randomAnimationsMask;
}

uint8_t ThemeManager::getRandomTestsMask() {
    return randomTestsMask;
}

void ThemeManager::handleSerial() {
    if (Serial.available()) {
        char command = Serial.read();
        while(Serial.available()) Serial.read();
        
        switch (command) {
            case '+': brightnessUp(); break;
            case '-': brightnessDown(); break;
            case 's': setTheme(THEME_CHRISTMAS_STATIC); break;
            case 'a': setTheme(THEME_CHRISTMAS_ANIMATED); break;
            case 'r': setTheme(THEME_RANDOM_MAGIC); break;
            case 't': setTheme(THEME_TEST_MODE); break;
            case 'c': setTheme(THEME_OFF); break;
            case 'n':
                if (currentTheme == THEME_CHRISTMAS_STATIC) {
                    currentScene = (currentScene + 1) % TOTAL_STATIC_SCENES;
                } else if (currentTheme == THEME_CHRISTMAS_ANIMATED) {
                    setSpecificAnimation((currentAnimation + 1) % TOTAL_ANIMATIONS);
                } else if (currentTheme == THEME_RANDOM_MAGIC) {
                    updateRandomMagic();
                }
                break;
            default:
                if (command >= '0' && command <= '9') {
                    uint8_t num = command - '0';
                    if (currentTheme == THEME_CHRISTMAS_STATIC || currentTheme == THEME_TEST_MODE) {
                        setSpecificScene(num);
                    } else if (currentTheme == THEME_CHRISTMAS_ANIMATED) {
                        setSpecificAnimation(num);
                    }
                }
                break;
        }
    }
}

void ThemeManager::drawStaticChristmasScene(int matrix, uint8_t sceneIndex) {
    // V15.2.3-2026-01-04T14:30:00Z - Load all Christmas scenes from SPIFFS
    if (!sceneData || matrix < 0 || matrix > 1) return;
    sceneIndex = sceneIndex % TOTAL_STATIC_SCENES;
    
    // V15.2.3-2026-01-04T14:30:00Z - Map scene indices to SPIFFS JSON files
    const char* sceneFiles[] = {
        "/christmas_tree.json",      // 0
        "/santa_claus.json",         // 1
        "/gift.json",                // 2
        "/frosty_snowman.json",      // 3
        "/giant_snowflake.json",     // 4
        "/yellow_gift.json"          // 5
    };
    
    // V15.2.3-2026-01-04T14:30:00Z - Attempt to load from SPIFFS
    if (!sceneData->renderSceneFromFile(sceneFiles[sceneIndex], matrix)) {
        Serial.printf("Failed to load %s from SPIFFS\n", sceneFiles[sceneIndex]);
        disp->clearMatrix(matrix); // V15.2.3-2026-01-04T14:30:00Z - Clear on failure
    }
}

void ThemeManager::drawTestScene(int matrix, uint8_t testIndex) {
    if (!testScenes || matrix < 0 || matrix > 1) return;
    
    if (currentTheme == THEME_RANDOM_MAGIC && testIndex >= TOTAL_TEST_PATTERNS) {
        testIndex = testIndex % TOTAL_TEST_PATTERNS;
    }
    
    if (currentTheme == THEME_TEST_MODE) {
        testIndex = testIndex % 6;
    }

    switch (testIndex) {
        case 0: testScenes->drawColorRows(matrix); break;
        case 1: testScenes->drawColorColumns(matrix); break;
        case 2: testScenes->drawAllWhite(matrix); break;
        case 3: testScenes->drawAllRed(matrix); break;
        case 4: testScenes->drawCornerTest(matrix); break;
        case 5: testScenes->drawGridTest(matrix); break;
    }
}

// V15.0.1-2026-01-03T14:00:00Z - Animation drawing (music removed, renumbered)
void ThemeManager::drawAnimation(int matrix, uint8_t animIndex) {
    if (matrix != 0) return;
    animIndex = animIndex % TOTAL_ANIMATIONS; 

    switch (animIndex) {
        case 0: snowfallEffect->setMode(MODE_BASIC); snowfallEffect->begin(); break;
        case 1: snowfallEffect->setMode(MODE_WIND_SINGLE); snowfallEffect->begin(); break;
        case 2: snowfallEffect->setMode(MODE_WIND_VARY); snowfallEffect->begin(); break;
        case 3: snowfallEffect->setMode(MODE_ACCUMULATE); snowfallEffect->begin(); break;
        case 4: snowfallEffect->setMode(MODE_VARY_SIZE); snowfallEffect->begin(); break;
        case 5: chaseAnimation->begin(); break;
        case 6: scrollAnimation->begin(); break;
        case 7: countdownAnimation->begin(); break;
        case 8: sparklingStar->begin(); break;
        case 9: spinningSnowflake->begin(); break;
        // V15.0.1-2026-01-03T14:00:00Z - Removed music (was 10-15), geometry renumbered
        case 10: concentricRectangles->begin(); break;  // Was 16
        case 11: concentricCircles->begin(); break;     // Was 17
        case 12: concentricTriangles->begin(); break;   // Was 18
        case 13: morphingGeometry->begin(); break;      // Was 19
        default: break; 
    }
}

void ThemeManager::findNextRandomScene() {
    uint8_t startScene = currentScene;
    
    for (int i = 0; i < TOTAL_STATIC_SCENES; i++) {
        currentScene = (currentScene + 1) % TOTAL_STATIC_SCENES;
        if ((randomScenesMask >> currentScene) & 0x01) {
            randomContentType = 0;
            return; 
        }
    }
    
    if (randomAnimationsMask != 0) {
        findNextRandomAnimation();
    } else if (randomTestsMask != 0) {
        findNextRandomTest();
    }
}

void ThemeManager::findNextRandomAnimation() {
    uint8_t startAnimation = currentAnimation;
    
    for (int i = 0; i < TOTAL_ANIMATIONS; i++) {
        currentAnimation = (currentAnimation + 1) % TOTAL_ANIMATIONS;
        if ((randomAnimationsMask >> currentAnimation) & 0x01) {
            drawAnimation(0, currentAnimation); 
            randomContentType = 1;
            return;
        }
    }
    
    if (randomScenesMask != 0) {
        findNextRandomScene();
    } else if (randomTestsMask != 0) {
        findNextRandomTest();
    }
}

void ThemeManager::findNextRandomTest() {
    uint8_t startTest = currentTest;
    
    for (int i = 0; i < TOTAL_TEST_PATTERNS; i++) {
        currentTest = (currentTest + 1) % TOTAL_TEST_PATTERNS;
        
        if (currentTest >= TOTAL_TEST_PATTERNS) {
            currentTest = 0;
        }
        
        if ((randomTestsMask >> currentTest) & 0x01) {
            randomContentType = 2;
            return;
        }
    }
    
    if (randomScenesMask != 0) {
        findNextRandomScene();
    } else if (randomAnimationsMask != 0) {
        findNextRandomAnimation();
    }
}

// V15.0.1-2026-01-03T14:00:00Z - Updated getCurrentInterval (removed music logic)
unsigned long ThemeManager::getCurrentInterval() {
    if (randomContentType == 0) {
        return STATIC_SCENE_INTERVAL;
    } else if (randomContentType == 2) {
        return STATIC_SCENE_INTERVAL;
    } else {
        // V15.0.1-2026-01-03T14:00:00Z - All animations use same interval (no music special case)
        return ANIMATION_INTERVAL;
    }
}

void ThemeManager::updateRandomMagic() {
    unsigned long currentTime = millis();
    
    if (currentTime - lastSceneChangeTime >= getCurrentInterval()) {
        lastSceneChangeTime = currentTime;
        
        int choice = random(3);
        
        if (choice == 0 && randomScenesMask != 0) {
            findNextRandomScene();
        } else if (choice == 1 && randomAnimationsMask != 0) {
            findNextRandomAnimation();
        } else if (choice == 2 && randomTestsMask != 0) {
            findNextRandomTest();
        } else {
            if (randomScenesMask != 0) findNextRandomScene();
            else if (randomAnimationsMask != 0) findNextRandomAnimation();
            else if (randomTestsMask != 0) findNextRandomTest();
        }
        
        if (randomContentType == 0) {
            disp->clear(); 
            drawStaticChristmasScene(0, currentScene);
            drawStaticChristmasScene(1, currentScene);
        } else if (randomContentType == 2) {
            disp->clear();
            drawTestScene(0, currentTest);
            drawTestScene(1, currentTest);
        }
    }
    
    if (randomContentType == 1) {
        updateCurrentAnimation();
    } else if (randomContentType == 2) {
        updateTestPattern();
    }
}

void ThemeManager::setBrightness(uint8_t brightness) {
    if (disp) {
        disp->setBrightness(brightness);
    }
}

void ThemeManager::brightnessUp() {
    uint8_t current = FastLED.getBrightness();
    uint8_t new_bright = constrain(current + 10, 10, 255);
    FastLED.setBrightness(new_bright);
    FastLED.show();
}

void ThemeManager::brightnessDown() {
    uint8_t current = FastLED.getBrightness();
    uint8_t new_bright = constrain(current - 10, 10, 255);
    FastLED.setBrightness(new_bright);
    FastLED.show();
}

// V15.0.1-2026-01-03T14:00:00Z - Countdown date configuration methods

void ThemeManager::initializeDefaultDates() {
    // Get current year
    time_t now = time(nullptr);
    struct tm* timeinfo = localtime(&now);
    uint16_t currentYear = timeinfo->tm_year + 1900;
    
    // Christmas default: Dec 25 at midnight (00:00)
    christmasCountdownDate.year = currentYear; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.month = 12; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.day = 25; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.hour = 0; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.minute = 0; // V15.0.2-2026-01-03T13:30:00Z
    
    // New Year default: Jan 1 (next year) at midnight
    newYearCountdownDate.year = currentYear + 1; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.month = 1; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.day = 1; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.hour = 0; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.minute = 0; // V15.0.2-2026-01-03T13:30:00Z
}

void ThemeManager::loadCountdownDates() {
    preferences.begin(PREFS_NAMESPACE, true);
    
    // Load Christmas countdown (or use defaults)
    if (preferences.isKey(COUNTDOWN_XMAS_YEAR_KEY)) {
        christmasCountdownDate.year = preferences.getUShort(COUNTDOWN_XMAS_YEAR_KEY, 2026); // V15.0.2-2026-01-03T13:30:00Z
        christmasCountdownDate.month = preferences.getUChar(COUNTDOWN_XMAS_MONTH_KEY, 12); // V15.0.2-2026-01-03T13:30:00Z
        christmasCountdownDate.day = preferences.getUChar(COUNTDOWN_XMAS_DAY_KEY, 25); // V15.0.2-2026-01-03T13:30:00Z
        christmasCountdownDate.hour = preferences.getUChar(COUNTDOWN_XMAS_HOUR_KEY, 0); // V15.0.2-2026-01-03T13:30:00Z
        christmasCountdownDate.minute = 0; // V15.0.2-2026-01-03T13:30:00Z
    } else {
        initializeDefaultDates();
    }
    
    // Load New Year countdown (or use defaults)
    if (preferences.isKey(COUNTDOWN_NEWYEAR_YEAR_KEY)) {
        newYearCountdownDate.year = preferences.getUShort(COUNTDOWN_NEWYEAR_YEAR_KEY, 2027); // V15.0.2-2026-01-03T13:30:00Z
        newYearCountdownDate.month = preferences.getUChar(COUNTDOWN_NEWYEAR_MONTH_KEY, 1); // V15.0.2-2026-01-03T13:30:00Z
        newYearCountdownDate.day = preferences.getUChar(COUNTDOWN_NEWYEAR_DAY_KEY, 1); // V15.0.2-2026-01-03T13:30:00Z
        newYearCountdownDate.hour = preferences.getUChar(COUNTDOWN_NEWYEAR_HOUR_KEY, 0); // V15.0.2-2026-01-03T13:30:00Z
        newYearCountdownDate.minute = 0; // V15.0.2-2026-01-03T13:30:00Z
    } else if (!preferences.isKey(COUNTDOWN_XMAS_YEAR_KEY)) {
        // Only init if we haven't already
        initializeDefaultDates();
    }
    
    preferences.end();
    
    logger.logf("Countdown dates loaded: Christmas=%04d-%02d-%02d, NewYear=%04d-%02d-%02d",
                christmasCountdownDate.year, christmasCountdownDate.month, christmasCountdownDate.day, // V15.0.2-2026-01-03T13:30:00Z
                newYearCountdownDate.year, newYearCountdownDate.month, newYearCountdownDate.day); // V15.0.2-2026-01-03T13:30:00Z
}

void ThemeManager::saveCountdownDates() {
    preferences.begin(PREFS_NAMESPACE, false);
    
    // Save Christmas countdown
    preferences.putUShort(COUNTDOWN_XMAS_YEAR_KEY, christmasCountdownDate.year); // V15.0.2-2026-01-03T13:30:00Z
    preferences.putUChar(COUNTDOWN_XMAS_MONTH_KEY, christmasCountdownDate.month); // V15.0.2-2026-01-03T13:30:00Z
    preferences.putUChar(COUNTDOWN_XMAS_DAY_KEY, christmasCountdownDate.day); // V15.0.2-2026-01-03T13:30:00Z
    preferences.putUChar(COUNTDOWN_XMAS_HOUR_KEY, christmasCountdownDate.hour); // V15.0.2-2026-01-03T13:30:00Z
    
    // Save New Year countdown
    preferences.putUShort(COUNTDOWN_NEWYEAR_YEAR_KEY, newYearCountdownDate.year); // V15.0.2-2026-01-03T13:30:00Z
    preferences.putUChar(COUNTDOWN_NEWYEAR_MONTH_KEY, newYearCountdownDate.month); // V15.0.2-2026-01-03T13:30:00Z
    preferences.putUChar(COUNTDOWN_NEWYEAR_DAY_KEY, newYearCountdownDate.day); // V15.0.2-2026-01-03T13:30:00Z
    preferences.putUChar(COUNTDOWN_NEWYEAR_HOUR_KEY, newYearCountdownDate.hour); // V15.0.2-2026-01-03T13:30:00Z
    
    preferences.end();
}

void ThemeManager::setChristmasCountdownDate(uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t minute) {
    christmasCountdownDate.year = year; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.month = month; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.day = day; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.hour = hour; // V15.0.2-2026-01-03T13:30:00Z
    christmasCountdownDate.minute = minute; // V15.0.2-2026-01-03T13:30:00Z
    saveCountdownDates();
    
    logger.logf("Christmas countdown set to: %04d-%02d-%02d %02d:%02d", 
                year, month, day, hour, minute);
}

void ThemeManager::setNewYearCountdownDate(uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t minute) {
    newYearCountdownDate.year = year; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.month = month; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.day = day; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.hour = hour; // V15.0.2-2026-01-03T13:30:00Z
    newYearCountdownDate.minute = minute; // V15.0.2-2026-01-03T13:30:00Z
    saveCountdownDates();
    
    logger.logf("New Year countdown set to: %04d-%02d-%02d %02d:%02d", 
                year, month, day, hour, minute);
}

CountdownDate ThemeManager::getChristmasCountdownDate() {
    return christmasCountdownDate; // V15.0.2-2026-01-03T13:30:00Z
}

CountdownDate ThemeManager::getNewYearCountdownDate() {
    return newYearCountdownDate; // V15.0.2-2026-01-03T13:30:00Z
}

void ThemeManager::resetCountdownDates() {
    initializeDefaultDates();
    saveCountdownDates();
    logger.log("Countdown dates reset to defaults");
}

time_t ThemeManager::countdownToEpoch(const CountdownDate& cd) {
    struct tm timeinfo = {0};
    timeinfo.tm_year = cd.year - 1900;
    timeinfo.tm_mon = cd.month - 1;
    timeinfo.tm_mday = cd.day;
    timeinfo.tm_hour = cd.hour;
    timeinfo.tm_min = cd.minute;
    timeinfo.tm_sec = 0;
    return mktime(&timeinfo);
}